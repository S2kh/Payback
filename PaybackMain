--!strict
-- Payback v7.4 (Glass Tabs, Keybinds, Beautiful Dropdowns, Mobile Float Button)
-- ✅ Strict Luau, 2025-valid APIs only
-- ✅ Built-in default tabs: UI Settings, Config, System (Unload + Menu Hotkey)
-- ✅ Keybind control + improved dropdowns (no blue outline, glass popup, checkmarks)
-- ✅ Live theme controls (unified + granular), Rainbow title toggle with smooth loop
-- ✅ Mobile reopen button (draggable square) when menu hidden

----------------------------------------------------------------
-- Type Aliases
----------------------------------------------------------------
type ToggleHandle = {
	Value: boolean,
	SetValue: (self: ToggleHandle, v: boolean) -> (),
	OnChanged: (self: ToggleHandle, fn: (boolean) -> ()) -> (),
}
type OptionHandle = {
	Value: any,
	SetValue: (self: OptionHandle, v: any) -> (),
	OnChanged: (self: OptionHandle, fn: (any) -> ()) -> (),
	SetValues: ((self: OptionHandle, newList: {any}, keep: boolean?) -> ())?,
	Get: (() -> string)?,
}
type NotifierArg = { Title: string?, Content: string?, Duration: number? }
type ThemeT = {
	Background: Color3, Panel: Color3, Panel2: Color3,
	Stroke: Color3, TextPrimary: Color3, TextMuted: Color3,
	Accent: Color3,
}
type EnvT = {
	IsMobile: boolean, Font: number, RowH: number,
	TogW: number, TogH: number, Knob: number, KnobInset: number,
	SliderH: number, InputH: number, Scrollbar: number,
	DropItem: number, DropMax: number, TabHeight: number, TabFont: number,
	BodyPadX: number, RowExtra: number,
}

----------------------------------------------------------------
-- Key gate
----------------------------------------------------------------
local SECRET: string = "ChromaXeno197"

----------------------------------------------------------------
-- Services
----------------------------------------------------------------
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local TextService = game:GetService("TextService")
local HttpService = game:GetService("HttpService")
local Lighting = game:GetService("Lighting")
local Workspace = game:GetService("Workspace")
local LP = Players.LocalPlayer

----------------------------------------------------------------
-- Globals
----------------------------------------------------------------
getgenv().Payback = getgenv().Payback or { Toggles = {}, Options = {}, Unloaded = false }

----------------------------------------------------------------
-- Helpers
----------------------------------------------------------------
local function GuiParent(): Instance
	local ok, gui = pcall(function() local f = (gethui :: any); return f and f() end)
	if ok and typeof(gui) == "Instance" then return gui end
	return (game:FindFirstChildOfClass("CoreGui") :: Instance?) or LP:WaitForChild("PlayerGui")
end

local function inst<T>(class: string, props: {[string]: any}?): T
	local o = Instance.new(class)
	for k, v in pairs(props or {}) do if k ~= "Parent" then (o :: any)[k] = v end end
	if props and (props :: any).Parent then (o :: any).Parent = (props :: any).Parent end
	-- remove blue gamepad outline everywhere
	if (o :: any).Selectable ~= nil then (o :: any).Selectable = false end
	return o :: any
end

local function alive(x: any): boolean
	return typeof(x) == "Instance" and (x :: Instance).Parent ~= nil
end

local function darker(c: Color3): Color3
	local h,s,v = Color3.toHSV(c)
	return Color3.fromHSV(h,s,math.clamp(v*0.74,0,1))
end

local function textW(t: string?, size: number?, font: Enum.Font?): number
	return TextService:GetTextSize(t or "", size or 14, font or Enum.Font.Gotham, Vector2.new(2048,1024)).X
end

local function safeTween(obj: Instance?, t: number?, props: {[string]: any}, style: Enum.EasingStyle?, dir: Enum.EasingDirection?)
	if not alive(obj) then return nil end
	local info = TweenInfo.new(t or 0.22, style or Enum.EasingStyle.Quad, dir or Enum.EasingDirection.Out)
	local ok, tw = pcall(TweenService.Create, TweenService, obj :: Instance, info, props)
	if ok and tw then tw:Play(); return tw end
	return nil
end

-- Color hex helpers
local function colorToHex(c: Color3): string
	local r = math.clamp(math.floor(c.R*255 + 0.5), 0, 255)
	local g = math.clamp(math.floor(c.G*255 + 0.5), 0, 255)
	local b = math.clamp(math.floor(c.B*255 + 0.5), 0, 255)
	return string.format("%02X%02X%02X", r, g, b)
end
local function hexToColor(hex: string): Color3
	local s = hex:gsub("#","")
	if #s == 3 then s = s:sub(1,1)..s:sub(1,1)..s:sub(2,2)..s:sub(2,2)..s:sub(3,3)..s:sub(3,3) end
	local r = tonumber(s:sub(1,2),16) or 255
	local g = tonumber(s:sub(3,4),16) or 255
	local b = tonumber(s:sub(5,6),16) or 255
	return Color3.fromRGB(r,g,b)
end

local function ripple(btn: Frame, pos: Vector2 | Vector3 | nil)
	if not alive(btn) then return end
	local mx, my
	if typeof(pos) == "Vector2" then mx, my = (pos :: Vector2).X, (pos :: Vector2).Y
	elseif typeof(pos) == "Vector3" then local v3 = pos :: Vector3; mx, my = v3.X, v3.Y
	else local m = UserInputService:GetMouseLocation(); mx, my = m.X, m.Y end
	local lx = math.clamp(mx - btn.AbsolutePosition.X, 0, btn.AbsoluteSize.X)
	local ly = math.clamp(my - btn.AbsolutePosition.Y, 0, btn.AbsoluteSize.Y)
	local d = math.max(btn.AbsoluteSize.X, btn.AbsoluteSize.Y) * 1.6
	local r = inst("Frame", {
		BackgroundColor3 = Color3.new(1,1,1), BackgroundTransparency = 0.8,
		AnchorPoint = Vector2.new(0.5,0.5), Position = UDim2.fromOffset(lx,ly),
		Size = UDim2.fromOffset(0,0), Parent = btn, ZIndex = (btn.ZIndex or 1)+1, ClipsDescendants = true,
	})
	inst("UICorner", { CornerRadius = UDim.new(1,0), Parent = r })
	local tw = safeTween(r, 0.33, { Size = UDim2.fromOffset(d,d), BackgroundTransparency = 1 })
	if tw then tw.Completed:Connect(function() if r then r:Destroy() end end) else task.delay(0.34, function() if r then r:Destroy() end end) end
end

local function defaultTheme(): ThemeT
	return {
		Background = Color3.fromRGB(16,20,28),
		Panel = Color3.fromRGB(22,26,36),
		Panel2 = Color3.fromRGB(28,34,46),
		Stroke = Color3.fromRGB(56,72,96),
		TextPrimary = Color3.fromRGB(242,246,255),
		TextMuted = Color3.fromRGB(170,182,198),
		Accent = Color3.fromRGB(0,186,255),
	}
end

----------------------------------------------------------------
-- Config manager
----------------------------------------------------------------
local Config = {}; Config.__index = Config
function Config.new(dir: string?) return setmetatable({ Directory = dir or "Payback-UI", Values = {}, Setters = {} }, Config) end
function Config:Set(k: string, v: any) if k and k ~= "" then self.Values[k] = v end end
function Config:Bind(k: string, fn: (any)->()) if k and k ~= "" then self.Setters[k] = fn end end
function Config:Save(name: string?)
	if not (writefile and isfolder and makefolder) then return false, "filesystem unavailable" end
	if not isfolder(self.Directory) then pcall(makefolder, self.Directory) end
	local ok, json = pcall(HttpService.JSONEncode, HttpService, self.Values); if not ok then return false, "encode failed" end
	pcall(writefile, ("%s/%s.json"):format(self.Directory, name or "default"), json); return true
end
function Config:Load(name: string?)
	if not (isfile and readfile) then return false, "filesystem unavailable" end
	local path = ("%s/%s.json"):format(self.Directory, name or "default")
	if not isfile(path) then return false, "no file" end
	local ok, t = pcall(function() return HttpService:JSONDecode(readfile(path)) end); if not ok then return false, "decode failed" end
	self.Values = t or self.Values
	for k, fn in pairs(self.Setters) do if self.Values[k] ~= nil then pcall(fn, self.Values[k]) end end
	return true
end

----------------------------------------------------------------
-- Notifier
----------------------------------------------------------------
local function createNotifier(screen: ScreenGui, theme: ThemeT)
	local holder = inst("Frame", {
		BackgroundTransparency = 1, AnchorPoint = Vector2.new(1,1),
		Position = UDim2.new(1,-16,1,-16), Size = UDim2.fromOffset(360,280), Parent = screen, ZIndex = 300,
	})
	inst("UIListLayout", { Parent = holder, Padding = UDim.new(0,8) })
	return function(o: NotifierArg?)
		o = o or {}; local dur = tonumber(o.Duration) or 4
		local card = inst("Frame", {
			BackgroundColor3 = theme.Panel2, BackgroundTransparency = 0.06, Size = UDim2.new(1,0,0,74),
			Parent = holder, ZIndex = 301,
		})
		inst("UICorner", { CornerRadius = UDim.new(0,10), Parent = card })
		inst("UIStroke", { ApplyStrokeMode = Enum.ApplyStrokeMode.Border, Color = theme.Stroke, Thickness = 1, Transparency = 0.2, Parent = card })
		inst("Frame", { BackgroundColor3 = theme.Accent, BorderSizePixel = 0, Size = UDim2.new(0,3,1,0), Parent = card, ZIndex = 302 })
		inst("TextLabel", {
			BackgroundTransparency = 1, Text = o.Title or "Payback", Font = Enum.Font.GothamBold, TextSize = 16, TextColor3 = theme.TextPrimary,
			TextXAlignment = Enum.TextXAlignment.Left, Position = UDim2.fromOffset(12,6), Size = UDim2.fromOffset(320,20), Parent = card, ZIndex = 303,
		})
		inst("TextLabel", {
			BackgroundTransparency = 1, Text = o.Content or "", Font = Enum.Font.Gotham, TextSize = 14, TextColor3 = theme.TextMuted,
			TextWrapped = true, TextXAlignment = Enum.TextXAlignment.Left, Position = UDim2.fromOffset(12,28), Size = UDim2.new(1,-24,0,36),
			Parent = card, ZIndex = 303,
		})
		card.Position = UDim2.new(1,380,0,0); safeTween(card, 0.32, { Position = UDim2.new(0,0,0,0) }, Enum.EasingStyle.Quint)
		local bar = inst("Frame", { BackgroundColor3 = theme.Accent, BackgroundTransparency = 0.3, Size = UDim2.new(1,0,0,3), Position = UDim2.new(0,0,1,-3), Parent = card, ZIndex = 304 })
		inst("UICorner", { CornerRadius = UDim.new(0,2), Parent = bar })
		local tw = safeTween(bar, dur, { Size = UDim2.new(0,0,0,3) })
		if tw then tw.Completed:Connect(function()
			safeTween(card, 0.18, { BackgroundTransparency = 1 })
			local t2 = safeTween(card, 0.2, { Position = UDim2.new(1,380,0,0) })
			if t2 then t2.Completed:Connect(function() if card then card:Destroy() end end) else task.delay(0.22, function() if card then card:Destroy() end end) end
		end) end
	end
end

----------------------------------------------------------------
-- Watermark / FPS HUD
----------------------------------------------------------------
local function createWatermark(screen: ScreenGui, theme: ThemeT)
	local wm = inst("TextLabel", {
		BackgroundColor3 = theme.Panel, BackgroundTransparency = 0.42,
		Text = "Payback", Font = Enum.Font.GothamBold, TextSize = 12, TextColor3 = theme.TextPrimary,
		Position = UDim2.fromOffset(12,12), Size = UDim2.fromOffset(170,22), Parent = screen, ZIndex = 120, Visible = false,
	})
	inst("UICorner", { CornerRadius = UDim.new(0,8), Parent = wm })
	inst("UIStroke", { ApplyStrokeMode = Enum.ApplyStrokeMode.Border, Color = theme.Stroke, Thickness = 1, Transparency = 0.24, Parent = wm })
	local aliveFlag = true
	task.spawn(function()
		while aliveFlag and alive(wm) do
			local frames, t0 = 0, os.clock()
			repeat frames += 1 RunService.RenderStepped:Wait() until os.clock() - t0 >= 1
			if wm.Visible and alive(wm) then wm.Text = string.format("Payback • %d FPS", frames) end
		end
	end)
	return {
		Show = function(_, b: boolean) if alive(wm) then wm.Visible = b and true or false end end,
		Destroy = function(_) aliveFlag = false; if wm then wm:Destroy() end end,
	}
end

----------------------------------------------------------------
-- Control Kit
----------------------------------------------------------------
local ControlKit = {}; ControlKit.__index = ControlKit
local function register(tbl: {[string]: any}, flag: string?, payload: any) if flag and flag ~= "" then tbl[flag] = payload end end
local function spring(uiobj: GuiObject?)
	if not alive(uiobj) then return end
	local s = (uiobj :: GuiObject):FindFirstChild("__PBScale") :: UIScale?
	s = s or inst("UIScale", { Name = "__PBScale", Parent = uiobj, Scale = 1 })
	local a = safeTween(s, 0.08, { Scale = 1.04 })
	if a then a.Completed:Connect(function() if alive(s) then safeTween(s, 0.14, { Scale = 1 }) end end) end
end
function ControlKit.new(container: Frame, theme: ThemeT, config: any, env: EnvT, registry: any, screen: ScreenGui, indexer: ((string, Frame)->())?)
	return setmetatable({ Holder = container, Theme = theme, Config = config, Env = env, Registry = registry, Screen = screen, Indexer = indexer }, ControlKit)
end
function ControlKit:_row(h: number)
	local r = inst("Frame", {
		BackgroundColor3 = self.Theme.Panel2, BackgroundTransparency = 0.06,
		Size = UDim2.new(1,0,0,h), Parent = self.Holder, ZIndex = (self.Holder.ZIndex or 0) + 1, ClipsDescendants = true,
	})
	inst("UICorner", { CornerRadius = UDim.new(0,10), Parent = r })
	inst("UIStroke", { ApplyStrokeMode = Enum.ApplyStrokeMode.Border, Color = self.Theme.Stroke, Thickness = 1, Transparency = 0.22, Parent = r })
	r.MouseEnter:Connect(function() spring(r) end)
	return r
end

function ControlKit:Divider()
	local row = self:_row(12)
	local line = inst("Frame", {
		BackgroundColor3 = self.Theme.Stroke, BackgroundTransparency = 0.4,
		Position = UDim2.fromOffset(self.Env.BodyPadX,5), Size = UDim2.new(1,-self.Env.BodyPadX*2,0,2),
		Parent = row, ZIndex = row.ZIndex + 1,
	})
	inst("UICorner", { CornerRadius = UDim.new(0,1), Parent = line })
	if self.Indexer then self.Indexer("divider", row) end
	return { Instance = row }
end

function ControlKit:Label(text: string?)
	local row = self:_row(self.Env.RowH)
	local lbl = inst("TextLabel", {
		BackgroundTransparency = 1, Text = tostring(text or ""), Font = Enum.Font.Gotham,
		TextSize = self.Env.Font, TextColor3 = self.Theme.TextMuted, TextXAlignment = Enum.TextXAlignment.Left, TextWrapped = true,
		Position = UDim2.fromOffset(self.Env.BodyPadX,0), Size = UDim2.new(1,-self.Env.BodyPadX*2,1,0), Parent = row, ZIndex = row.ZIndex + 1,
	})
	if self.Indexer then self.Indexer("label_"..(text or ""), row) end
	return { Instance = row, SetText = function(_: any, t: string?) lbl.Text = tostring(t or "") end }
end

function ControlKit:Button(o: {Name: string?, Callback: (() -> ())?}?)
	o = o or {}
	local row = self:_row(self.Env.RowH)
	local lbl = inst("TextLabel", {
		BackgroundTransparency = 1, Text = o.Name or "Button", Font = Enum.Font.GothamMedium,
		TextSize = self.Env.Font, TextColor3 = self.Theme.TextPrimary, TextXAlignment = Enum.TextXAlignment.Left,
		Position = UDim2.fromOffset(self.Env.BodyPadX,0), Size = UDim2.new(1, -(self.Env.BodyPadX*2 + 24), 1, 0), Parent = row, ZIndex = row.ZIndex + 1,
	})
	inst("TextLabel", {
		BackgroundTransparency = 1, Text = "▸", Font = Enum.Font.GothamBold, TextSize = self.Env.Font+2, TextColor3 = self.Theme.TextMuted,
		TextXAlignment = Enum.TextXAlignment.Right, AnchorPoint = Vector2.new(1,0.5),
		Position = UDim2.new(1,-self.Env.BodyPadX,0.5,0), Size = UDim2.fromOffset(24,24), Parent = row, ZIndex = lbl.ZIndex,
	})
	row.InputBegan:Connect(function(i)
		if i.UserInputType == Enum.UserInputType.MouseButton1 or i.UserInputType == Enum.UserInputType.Touch then
			ripple(row, (i :: any).Position); task.spawn(o.Callback or function() end)
		end
	end)
	if self.Indexer then self.Indexer(o.Name or "Button", row) end
	return { Instance = row }
end

function ControlKit:Toggle(o: {Name: string?, Flag: string?, Default: boolean?, Callback: ((boolean)->())?}?)
	o = o or {}
	local text, flag = o.Name or "Toggle", o.Flag
	local state = o.Default == true
	local callbacks: {((boolean)->())} = {}
	local row = self:_row(self.Env.RowH)
	inst("TextLabel", {
		BackgroundTransparency = 1, Text = text, Font = Enum.Font.GothamMedium, TextSize = self.Env.Font, TextColor3 = self.Theme.TextPrimary,
		TextXAlignment = Enum.TextXAlignment.Left, Position = UDim2.fromOffset(self.Env.BodyPadX,0),
		Size = UDim2.new(1,-(self.Env.BodyPadX*2 + self.Env.TogW + 18),1,0), Parent = row, ZIndex = row.ZIndex + 1,
	})
	local box = inst("Frame", {
		BackgroundColor3 = state and self.Theme.Accent or Color3.fromRGB(66,72,86), BackgroundTransparency = 0.08,
		AnchorPoint = Vector2.new(1,0.5), Position = UDim2.new(1,-self.Env.BodyPadX,0.5,0),
		Size = UDim2.fromOffset(self.Env.TogW, self.Env.TogH), Parent = row, ZIndex = row.ZIndex + 1,
	})
	inst("UICorner", { CornerRadius = UDim.new(1,0), Parent = box })
	inst("UIStroke", { ApplyStrokeMode = Enum.ApplyStrokeMode.Border, Color = self.Theme.Stroke, Thickness = 1, Transparency = 0.25, Parent = box })
	local knob = inst("Frame", {
		BackgroundColor3 = Color3.fromRGB(252,252,255), AnchorPoint = Vector2.new(0.5,0.5),
		Position = UDim2.fromOffset(state and (self.Env.TogW - self.Env.KnobInset) or self.Env.KnobInset, math.floor(self.Env.TogH/2)),
		Size = UDim2.fromOffset(self.Env.Knob, self.Env.Knob), Parent = box, ZIndex = box.ZIndex + 1,
	})
	inst("UICorner", { CornerRadius = UDim.new(1,0), Parent = knob })
	local function fire(v: boolean)
		if o and o.Callback then task.spawn(o.Callback, v) end
		for _, fn in ipairs(callbacks) do task.spawn(fn, v) end
	end
	local function apply(v: boolean, fromLoad: boolean?)
		state = v and true or false
		safeTween(knob, 0.14, { Position = UDim2.fromOffset(state and (self.Env.TogW - self.Env.KnobInset) or self.Env.KnobInset, math.floor(self.Env.TogH/2)) })
		safeTween(box, 0.14, { BackgroundColor3 = state and self.Theme.Accent or Color3.fromRGB(66,72,86) })
		self.Config:Set(flag or "", state)
		if not fromLoad then fire(state) end
	end
	row.InputBegan:Connect(function(i)
		if i.UserInputType == Enum.UserInputType.MouseButton1 or i.UserInputType == Enum.UserInputType.Touch then ripple(row, (i :: any).Position); apply(not state) end
	end)
	if flag then
		self.Config:Bind(flag, function(v) apply(v, true) end)
		self.Config:Set(flag, state)
		register(getgenv().Payback.Toggles, flag, {
			Value = state,
			SetValue = function(_: any, v: boolean) apply(v) end,
			OnChanged = function(_: any, fn: (boolean)->()) table.insert(callbacks, fn); fn(state) end,
		})
	end
	if self.Indexer then self.Indexer(text, row) end
	return { Instance = row }
end

function ControlKit:Slider(o: {Name: string?, Min: number?, Max: number?, Step: number?, Default: number?, Flag: string?, Callback: ((number)->())?}?)
	o = o or {}
	local text = o.Name or "Slider"
	local min = tonumber(o.Min or 0) :: number
	local max = tonumber(o.Max or 100) :: number
	local step = tonumber(o.Step or 1) :: number
	local def = tonumber(o.Default or min) :: number
	local flag = o.Flag
	local callbacks: {((number)->())} = {}
	local val = math.clamp(def, min, max)
	local row = self:_row(self.Env.RowH + 10)
	local label = inst("TextLabel", {
		BackgroundTransparency = 1, Text = ("%s: %s"):format(text, tostring(val)),
		Font = Enum.Font.GothamMedium, TextSize = self.Env.Font, TextColor3 = self.Theme.TextPrimary, TextXAlignment = Enum.TextXAlignment.Left,
		Position = UDim2.fromOffset(self.Env.BodyPadX,4), Size = UDim2.new(1,-self.Env.BodyPadX*2,0,self.Env.Font+4), Parent = row, ZIndex = row.ZIndex + 1,
	})
	local track = inst("Frame", {
		BackgroundColor3 = Color3.fromRGB(64,70,84), BackgroundTransparency = 0.12,
		Position = UDim2.new(0,self.Env.BodyPadX,0,self.Env.RowH - math.floor(self.Env.SliderH/2) + 2),
		Size = UDim2.new(1, -(self.Env.BodyPadX*2 + self.Env.RowExtra), 0, self.Env.SliderH), Parent = row, ZIndex = row.ZIndex + 1,
	})
	inst("UICorner", { CornerRadius = UDim.new(0, math.floor(self.Env.SliderH/2)), Parent = track })
	inst("UIStroke", { ApplyStrokeMode = Enum.ApplyStrokeMode.Border, Color = self.Theme.Stroke, Thickness = 1, Transparency = 0.25, Parent = track })
	local fill = inst("Frame", { BackgroundColor3 = self.Theme.Accent, Size = UDim2.new((val-min)/math.max(1,(max-min)),0,1,0), Parent = track, ZIndex = track.ZIndex + 1 })
	inst("UICorner", { CornerRadius = UDim.new(0, math.floor(self.Env.SliderH/2)), Parent = fill })
	local function fire(v: number) if o and o.Callback then task.spawn(o.Callback, v) end for _, f in ipairs(callbacks) do task.spawn(f, v) end end
	local function setDirect(v: number)
		local nv = min + math.round((math.clamp(v, min, max) - min) / step) * step
		val = math.clamp(nv, min, max)
		label.Text = ("%s: %s"):format(text, tostring(val))
		safeTween(fill, 0.10, { Size = UDim2.new((val-min)/math.max(1,(max-min)),0,1,0) })
		self.Config:Set(flag or "", val); fire(val)
	end
	local dragging = false
	track.InputBegan:Connect(function(i)
		if i.UserInputType == Enum.UserInputType.MouseButton1 or i.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			local p = math.clamp(((i :: any).Position.X - track.AbsolutePosition.X)/math.max(1,track.AbsoluteSize.X), 0, 1)
			setDirect(min + (max - min) * p)
		end
	end)
	track.InputEnded:Connect(function(i) if i.UserInputType == Enum.UserInputType.MouseButton1 or i.UserInputType == Enum.UserInputType.Touch then dragging = false end end)
	UserInputService.InputChanged:Connect(function(i)
		if dragging and (i.UserInputType == Enum.UserInputType.MouseMovement or i.UserInputType == Enum.UserInputType.Touch) then
			local p = math.clamp((i.Position.X - track.AbsolutePosition.X) / math.max(1, track.AbsoluteSize.X), 0, 1)
			setDirect(min + (max - min) * p)
		end
	end)
	if flag then
		self.Config:Bind(flag, function(v) setDirect(tonumber(v) or val) end)
		self.Config:Set(flag, val)
		register(getgenv().Payback.Options, flag, {
			Value = val,
			SetValue = function(_: any, v: number) setDirect(v) end,
			OnChanged = function(_: any, fn: (number)->()) table.insert(callbacks, fn); fn(val) end,
		})
	end
	if self.Indexer then self.Indexer(text, row) end
	return { Instance = row }
end

-- NEW: Keybind control
function ControlKit:Keybind(o: {Name: string?, Flag: string?, Default: Enum.KeyCode?, Callback: ((Enum.KeyCode?)->())?}?)
	o = o or {}
	local text, flag = o.Name or "Keybind", o.Flag
	local current: Enum.KeyCode? = (o.Default and (typeof(o.Default)=="EnumItem" and o.Default or nil)) :: Enum.KeyCode?
	local listening = false
	local callbacks: {((Enum.KeyCode?)->())} = {}

	local row = self:_row(self.Env.RowH)
	local lbl = inst("TextLabel", {
		BackgroundTransparency = 1, Text = text, Font = Enum.Font.GothamMedium, TextSize = self.Env.Font, TextColor3 = self.Theme.TextPrimary,
		TextXAlignment = Enum.TextXAlignment.Left, Position = UDim2.fromOffset(self.Env.BodyPadX,0), Size = UDim2.new(1,-(self.Env.BodyPadX*2 + 120),1,0),
		Parent = row, ZIndex = row.ZIndex + 1,
	})
	local capsule = inst("TextButton", {
		AutoButtonColor = false, Text = (current and current.Name) or "Set…",
		Font = Enum.Font.Gotham, TextSize = self.Env.Font, TextColor3 = self.Theme.TextPrimary,
		BackgroundColor3 = Color3.fromRGB(66,72,86), BackgroundTransparency = 0.12,
		AnchorPoint = Vector2.new(1,0.5), Position = UDim2.new(1,-self.Env.BodyPadX,0.5,0),
		Size = UDim2.fromOffset(100, self.Env.InputH), Parent = row, ZIndex = row.ZIndex + 1,
	})
	inst("UICorner", { CornerRadius = UDim.new(0,8), Parent = capsule })
	inst("UIStroke", { ApplyStrokeMode = Enum.ApplyStrokeMode.Border, Color = self.Theme.Stroke, Thickness = 1, Transparency = 0.25, Parent = capsule })

	local function apply(k: Enum.KeyCode?)
		current = k
		capsule.Text = (k and k.Name) or "Set…"
		self.Config:Set(flag or "", k and k.Name or "")
		if o and o.Callback then o.Callback(k) end
		for _, f in ipairs(callbacks) do f(k) end
	end

	capsule.MouseButton1Click:Connect(function()
		if listening then return end
		ripple(capsule, nil); listening = true; capsule.Text = "Listening…"
	end)
	capsule.MouseButton2Click:Connect(function() -- right-click clears
		apply(nil)
	end)

	UserInputService.InputBegan:Connect(function(i, gpe)
		if not listening or gpe then return end
		if i.KeyCode ~= Enum.KeyCode.Unknown then
			listening = false; apply(i.KeyCode)
		end
	end)

	if flag then
		self.Config:Bind(flag, function(v)
			if typeof(v) == "string" and (Enum.KeyCode :: any)[v] then apply((Enum.KeyCode :: any)[v]) end
		end)
		self.Config:Set(flag, current and current.Name or "")
		register(getgenv().Payback.Options, flag, {
			Value = current and current.Name or "",
			SetValue = function(_: any, v: any)
				if typeof(v) == "EnumItem" then apply(v :: Enum.KeyCode)
				elseif typeof(v) == "string" and (Enum.KeyCode :: any)[v] then apply((Enum.KeyCode :: any)[v]) end
			end,
			OnChanged = function(_: any, fn: (Enum.KeyCode?)->()) table.insert(callbacks, fn); fn(current) end,
		})
	end

	if self.Indexer then self.Indexer(text, row) end
	return { Instance = row }
end

-- BEAUTIFIED Dropdown (glass popup, checkmarks, no outline)
function ControlKit:Dropdown(o: {Name: string?, List: {any}?, Default: any?, Multi: boolean?, Flag: string?, Callback: ((any)->())?}?)
	o = o or {}
	local text = o.Name or "Dropdown"
	local list = (o.List and table.clone(o.List)) or { "A", "B" }
	local multi = (o.Multi == true)
	local def = o.Default or (multi and {} or list[1])
	local flag: string? = o.Flag
	local callbacks: {((any)->())} = {}
	local value: any = multi and {} or def

	local row = self:_row(self.Env.RowH)
	local label = inst("TextLabel", {
		BackgroundTransparency = 1, Text = "", Font = Enum.Font.GothamMedium, TextSize = self.Env.Font,
		TextColor3 = self.Theme.TextPrimary, TextXAlignment = Enum.TextXAlignment.Left,
		Position = UDim2.fromOffset(self.Env.BodyPadX,0), Size = UDim2.new(1,-self.Env.BodyPadX*2,1,0), Parent = row, ZIndex = row.ZIndex + 1,
	})
	local caret = inst("TextLabel", {
		BackgroundTransparency = 1, Text = "▾", Font = Enum.Font.GothamBold, TextSize = self.Env.Font + 2, TextColor3 = self.Theme.TextMuted,
		AnchorPoint = Vector2.new(1,0.5), Position = UDim2.new(1,-self.Env.BodyPadX,0.5,0), Size = UDim2.fromOffset(16,16),
		Parent = row, ZIndex = row.ZIndex + 2,
	})

	-- Floating glass popup
	local popup = inst("Frame", {
		BackgroundColor3 = self.Theme.Panel, BackgroundTransparency = 0.04,
		Size = UDim2.new(1, -(self.Env.BodyPadX*2), 0, 0), Position = UDim2.new(0,self.Env.BodyPadX,1,6),
		Parent = row, ZIndex = row.ZIndex + 20, ClipsDescendants = true, Visible = false,
	})
	inst("UICorner", { CornerRadius = UDim.new(0,10), Parent = popup })
	inst("UIStroke", { ApplyStrokeMode = Enum.ApplyStrokeMode.Border, Color = self.Theme.Stroke, Thickness = 1, Transparency = 0.22, Parent = popup })
	local menu = inst("ScrollingFrame", {
		BackgroundTransparency = 1, BorderSizePixel = 0, CanvasSize = UDim2.fromOffset(0,0),
		AutomaticCanvasSize = Enum.AutomaticSize.Y, ScrollBarThickness = self.Env.Scrollbar,
		ScrollingDirection = Enum.ScrollingDirection.Y, Size = UDim2.fromScale(1,1),
		Parent = popup, ZIndex = popup.ZIndex + 1,
	})
	local lay = inst("UIListLayout", { Parent = menu, Padding = UDim.new(0,6) })
	inst("UIPadding", { Parent = menu, PaddingTop = UDim.new(0,6), PaddingLeft = UDim.new(0,6), PaddingRight = UDim.new(0,6), PaddingBottom = UDim.new(0,6) })

	local function vtext(): string
		if multi then
			local t: {string} = {}
			for k,_ in pairs(value) do table.insert(t, tostring(k)) end
			table.sort(t)
			return (next(t) and table.concat(t, ", ")) or "--"
		else
			return tostring(value or "--")
		end
	end

	local function targetHeight(): number
		local h = lay.AbsoluteContentSize.Y + 12
		return math.clamp(h, 0, self.Env.DropMax)
	end
	lay:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
		menu.CanvasSize = UDim2.fromOffset(0, lay.AbsoluteContentSize.Y + 12)
	end)

	local function rebuildItems()
		for _, c in ipairs(menu:GetChildren()) do if c:IsA("TextButton") then c:Destroy() end end
		for _, it in ipairs(list) do
			local b = inst("TextButton", {
				AutoButtonColor = false, BackgroundColor3 = Color3.fromRGB(66,72,86), BackgroundTransparency = 0.15,
				Text = "", Font = Enum.Font.Gotham, TextSize = self.Env.Font, TextColor3 = self.Theme.TextPrimary,
				Size = UDim2.new(1, -12, 0, self.Env.DropItem), Parent = menu, ZIndex = menu.ZIndex,
			})
			inst("UICorner", { CornerRadius = UDim.new(0,8), Parent = b })
			inst("UIStroke", { ApplyStrokeMode = Enum.ApplyStrokeMode.Border, Color = Color3.fromRGB(88,96,114), Thickness = 1, Transparency = 0.35, Parent = b })

			local txt = inst("TextLabel", {
				BackgroundTransparency = 1, Text = tostring(it),
				Font = Enum.Font.Gotham, TextSize = self.Env.Font, TextColor3 = self.Theme.TextPrimary,
				TextXAlignment = Enum.TextXAlignment.Left, Position = UDim2.fromOffset(10,0), Size = UDim2.new(1,-40,1,0),
				Parent = b, ZIndex = b.ZIndex + 1,
			})
			local tick = inst("TextLabel", {
				BackgroundTransparency = 1, Text = "✓", Font = Enum.Font.GothamBold, TextSize = self.Env.Font + 2,
				TextColor3 = self.Theme.Accent, AnchorPoint = Vector2.new(1,0.5), Position = UDim2.new(1,-10,0.5,0),
				Size = UDim2.fromOffset(18,18), Parent = b, ZIndex = b.ZIndex + 1, Visible = (not multi and value == it) or (multi and value[it] ~= nil),
			})

			b.MouseEnter:Connect(function() spring(b) end)
			b.InputBegan:Connect(function(i) if i.UserInputType == Enum.UserInputType.MouseButton1 then ripple(b, (i :: any).Position) end end)
			b.MouseButton1Click:Connect(function()
				if multi then value[it] = not value[it] and true or nil else value = it end
				label.Text = text .. ": " .. vtext()
				tick.Visible = (not multi and value == it) or (multi and value[it] ~= nil)
				self.Config:Set(flag or "", value)
				if o and o.Callback then o.Callback(value) end
				for _, f in ipairs(callbacks) do f(value) end
				if not multi then
					safeTween(popup, 0.18, { Size = UDim2.new(1, -(self.Env.BodyPadX*2), 0, 0) }); popup.Visible = false; caret.Rotation = 0
				end
			end)
		end
		label.Text = text .. ": " .. vtext()
	end
	rebuildItems()

	local opened = false
	row.InputBegan:Connect(function(i)
		if i.UserInputType == Enum.UserInputType.MouseButton1 or i.UserInputType == Enum.UserInputType.Touch then
			ripple(row, (i :: any).Position); opened = not opened
			if opened then
				popup.Visible = true
				safeTween(popup, 0.18, { Size = UDim2.new(1, -(self.Env.BodyPadX*2), 0, targetHeight()) })
			else
				safeTween(popup, 0.18, { Size = UDim2.new(1, -(self.Env.BodyPadX*2), 0, 0) })
				task.delay(0.18, function() if alive(popup) then popup.Visible = false end end)
			end
			caret.Rotation = opened and 180 or 0
		end
	end)

	local function setList(newList: {any}?, keepSelection: boolean?)
		list = {}
		for i=1, #(newList or {}) do list[i] = (newList :: any)[i] end
		if not keepSelection then value = multi and {} or list[1] end
		rebuildItems()
		if opened then safeTween(popup, 0.05, { Size = UDim2.new(1, -(self.Env.BodyPadX*2), 0, targetHeight()) }) end
	end

	if flag then
		self.Config:Bind(flag, function(v) value = multi and (v or {}) or v; label.Text = text .. ": " .. vtext(); rebuildItems() end)
		self.Config:Set(flag, value)
		register(getgenv().Payback.Options, flag, {
			Value = value,
			SetValue = function(_: any, v: any)
				value = multi and (v or {}) or v
				self.Config:Set(flag or "", value)
				label.Text = text .. ": " .. vtext()
				if o and o.Callback then o.Callback(value) end
				rebuildItems()
			end,
			SetValues = function(_: any, newList: {any}, keep: boolean?) setList(newList, keep) end,
			OnChanged = function(_: any, fn: (any)->()) table.insert(callbacks, fn); fn(value) end,
		})
	end

	if self.Indexer then self.Indexer(text, row) end
	return { Instance = row, Refresh = function(_: any, newList: {any}, keep: boolean?) setList(newList, keep) end }
end

function ControlKit:Textbox(o: {Name: string?, Placeholder: string?, Flag: string?, Callback: ((string)->())?}?)
	o = o or {}
	local text, ph, flag = o.Name or "Textbox", o.Placeholder or "Type…", o.Flag
	local callbacks: {((string)->())} = {}
	local value = ""
	local row = self:_row(self.Env.RowH)
	inst("TextLabel", {
		BackgroundTransparency = 1, Text = text, Font = Enum.Font.GothamMedium, TextSize = self.Env.Font, TextColor3 = self.Theme.TextPrimary,
		TextXAlignment = Enum.TextXAlignment.Left, Position = UDim2.fromOffset(self.Env.BodyPadX,0), Size = UDim2.new(1,-self.Env.BodyPadX*2,1,0),
		Parent = row, ZIndex = row.ZIndex + 1,
	})
	local box = inst("TextBox", {
		BackgroundColor3 = Color3.fromRGB(66,72,86), BackgroundTransparency = 0.12,
		PlaceholderText = ph, Text = "", Font = Enum.Font.Gotham, TextSize = self.Env.Font, TextColor3 = self.Theme.TextPrimary,
		ClearTextOnFocus = false, AnchorPoint = Vector2.new(1,0.5), Position = UDim2.new(1,-self.Env.BodyPadX,0.5,0), Size = UDim2.new(0.55,0,0,self.Env.InputH),
		Parent = row, ZIndex = row.ZIndex + 1,
	})
	inst("UICorner", { CornerRadius = UDim.new(0,8), Parent = box })
	inst("UIStroke", { ApplyStrokeMode = Enum.ApplyStrokeMode.Border, Color = self.Theme.Stroke, Thickness = 1, Transparency = 0.25, Parent = box })
	local function commit(txt: string, fromLoad: boolean?)
		value = tostring(txt or ""); self.Config:Set(flag or "", value)
		local opt = flag and getgenv().Payback.Options[flag]; if opt then opt.Value = value end
		if not fromLoad then
			if o and o.Callback then o.Callback(value) end
			for _, f in ipairs(callbacks) do f(value) end
		end
	end
	box:GetPropertyChangedSignal("Text"):Connect(function() commit(box.Text) end)
	box.FocusLost:Connect(function() commit(box.Text) end)
	if flag then
		self.Config:Bind(flag, function(v) box.Text = tostring(v or ""); commit(box.Text, true) end)
		self.Config:Set(flag, value)
		register(getgenv().Payback.Options, flag, {
			Value = value,
			SetValue = function(_: any, v: string) box.Text = tostring(v or ""); commit(box.Text) end,
			Get = function() return box.Text end,
			OnChanged = function(_: any, fn: (string)->()) table.insert(callbacks, fn); fn(value) end,
		})
	end
	if self.Indexer then self.Indexer(text, row) end
	return { Instance = row }
end

----------------------------------------------------------------
-- Tabs / Window
----------------------------------------------------------------
local Tab = {}; Tab.__index = Tab
function Tab:_build(theme: ThemeT, env: EnvT, indexer: ((string, Frame)->())?)
	local w = math.max(80, textW(self.Name, env.TabFont, Enum.Font.GothamBold) + 18)
	self.Button = inst("TextButton", { AutoButtonColor = false, BackgroundTransparency = 1, Text = self.Name, Font = Enum.Font.GothamBold, TextSize = env.TabFont, TextColor3 = theme.TextMuted, Size = UDim2.fromOffset(w, env.TabHeight), Parent = self.TabBar, ZIndex = self.TabBar.ZIndex + 1 })
	self.Under  = inst("Frame", { BackgroundColor3 = theme.Accent, BorderSizePixel = 0, Size = UDim2.new(1,0,0,2), Position = UDim2.new(0,0,1,0), Parent = self.Button, ZIndex = self.Button.ZIndex + 1 })
	self.Under.Visible = false
	self.Page = inst("ScrollingFrame", {
		BackgroundColor3 = theme.Panel, BackgroundTransparency = 0.50, BorderSizePixel = 0,
		ScrollBarThickness = env.Scrollbar, ScrollingDirection = Enum.ScrollingDirection.Y,
		CanvasSize = UDim2.fromOffset(0,0), AutomaticCanvasSize = Enum.AutomaticSize.Y,
		Size = UDim2.new(1,0,1,0), Parent = self.Pages, ZIndex = self.Pages.ZIndex + 1, ClipsDescendants = true,
	})
	inst("UICorner", { CornerRadius = UDim.new(0,12), Parent = self.Page })
	inst("UIStroke", { ApplyStrokeMode = Enum.ApplyStrokeMode.Border, Color = theme.Stroke, Thickness = 1, Transparency = 0.30, Parent = self.Page })
	local design = inst("Frame", { Name = "DesignLayer", BackgroundTransparency = 1, Position = UDim2.fromOffset(-2,-2), Size = UDim2.new(1,4,1,4), Parent = self.Page, ZIndex = self.Page.ZIndex })
	inst("ImageLabel", { BackgroundTransparency = 1, Image = "rbxassetid://5553946656", ScaleType = Enum.ScaleType.Tile, TileSize = UDim2.fromOffset(96,96), ImageTransparency = 0.95, Size = UDim2.fromScale(1,1), Parent = design, ZIndex = design.ZIndex })
	local safe = inst("Frame", { Name = "SafeArea", BackgroundTransparency = 1, Size = UDim2.new(1,0,1,0), Parent = self.Page, ZIndex = self.Page.ZIndex + 1, AutomaticSize = Enum.AutomaticSize.Y })
	inst("UIPadding", { Parent = safe, PaddingTop = UDim.new(0,24), PaddingLeft = UDim.new(0,24), PaddingRight = UDim.new(0,24), PaddingBottom = UDim.new(0,18) })
	local columns = inst("Frame", { BackgroundTransparency = 1, Parent = safe, Size = UDim2.new(1,0,0,0), ZIndex = safe.ZIndex + 1, AutomaticSize = Enum.AutomaticSize.Y })
	local half = 12
	local left  = inst("Frame", { BackgroundTransparency = 1, Size = UDim2.new(0.5,-half,0,0), Position = UDim2.fromOffset(0,0), Parent = columns, ZIndex = columns.ZIndex, AutomaticSize = Enum.AutomaticSize.Y })
	local right = inst("Frame", { BackgroundTransparency = 1, Size = UDim2.new(0.5,-half,0,0), Position = UDim2.new(0.5,half,0,0), Parent = columns, ZIndex = columns.ZIndex, AutomaticSize = Enum.AutomaticSize.Y })
	inst("UIListLayout", { Parent = left,  Padding = UDim.new(0,12) })
	inst("UIListLayout", { Parent = right, Padding = UDim.new(0,12) })
	self.Left, self.Right, self.Columns = left, right, columns
	self.ControlKitLeft  = ControlKit.new(left,  self.Theme, self.Config, self.Env, getgenv().Payback, self.Screen, indexer)
	self.ControlKitRight = ControlKit.new(right, self.Theme, self.Config, self.Env, getgenv().Payback, self.Screen, indexer)
	self.Button.MouseEnter:Connect(function() spring(self.Button) end)
	self.Button.InputBegan:Connect(function(i) if i.UserInputType == Enum.UserInputType.MouseButton1 then ripple(self.Button, (i :: any).Position) end end)
	self.Button.MouseButton1Click:Connect(function() if self.Select then self.Select() end end)
end

function Tab:AddSection(name: string?, side: string?)
	local container = (side == "right") and self.Right or self.Left
	local section = inst("Frame", { BackgroundColor3 = self.Theme.Panel2, BackgroundTransparency = 0.38, Size = UDim2.new(1,0,0,28), Parent = container, ZIndex = container.ZIndex + 1 })
	inst("UICorner", { CornerRadius = UDim.new(0,10), Parent = section })
	inst("UIStroke", { ApplyStrokeMode = Enum.ApplyStrokeMode.Border, Color = self.Theme.Stroke, Thickness = 1, Transparency = 0.30, Parent = section })
	inst("TextLabel", { BackgroundTransparency = 1, Font = Enum.Font.GothamBold, Text = name or "Section", TextSize = self.ControlKitLeft.Env.Font, TextColor3 = self.Theme.TextMuted, TextXAlignment = Enum.TextXAlignment.Left, Position = UDim2.fromOffset(12,2), Size = UDim2.new(1,-24,0,24), Parent = section, ZIndex = section.ZIndex + 1 })
	local body = inst("Frame", { BackgroundTransparency = 1, Position = UDim2.fromOffset(0,28), Size = UDim2.new(1,0,0,0), Parent = section, ZIndex = section.ZIndex + 1, AutomaticSize = Enum.AutomaticSize.Y })
	inst("UIPadding", { Parent = body, PaddingTop = UDim.new(0,14), PaddingLeft = UDim.new(0,14), PaddingRight = UDim.new(0,14), PaddingBottom = UDim.new(0,14) })
	inst("UIListLayout", { Parent = body, Padding = UDim.new(0,10) })
	section.AutomaticSize = Enum.AutomaticSize.Y
	return ControlKit.new(body, self.Theme, self.Config, self.ControlKitLeft.Env, getgenv().Payback, self.Screen, function(n: string, frame: Frame)
		self._index = self._index or {}; table.insert(self._index, { string.lower(tostring(n or "")), frame })
	end)
end
function Tab:Controls(side: string?) return (side == "right") and self.ControlKitRight or self.ControlKitLeft end

----------------------------------------------------------------
-- Window
----------------------------------------------------------------
local PaybackLib = {}; PaybackLib.__index = PaybackLib
local Window = {}; Window.__index = Window

function PaybackLib:CreateWindow(o: { Title: string?, Accent: Color3?, Keybind: any?, ConfigDir: string?, Theme: ThemeT? }?)
	o = o or {}
	-- cleanup
	do
		local cg = game:FindFirstChildOfClass("CoreGui")
		if cg and cg:FindFirstChild("PaybackUI") then (cg :: any).PaybackUI:Destroy() end
		local b = Lighting:FindFirstChild("PaybackBlur"); if b then b:Destroy() end
	end
	local cam = Workspace.CurrentCamera
	local vw, vh = (cam and cam.ViewportSize.X or 1280), (cam and cam.ViewportSize.Y or 720)
	local theme: ThemeT = o.Theme or defaultTheme(); if o.Accent then theme.Accent = o.Accent end
	local env: EnvT = {
		IsMobile = UserInputService.TouchEnabled, Font = UserInputService.TouchEnabled and 16 or 14,
		RowH = UserInputService.TouchEnabled and 46 or 38, TogW = UserInputService.TouchEnabled and 50 or 34,
		TogH = UserInputService.TouchEnabled and 26 or 20, Knob = UserInputService.TouchEnabled and 18 or 12,
		KnobInset = UserInputService.TouchEnabled and 14 or 10, SliderH = UserInputService.TouchEnabled and 12 or 10,
		InputH = UserInputService.TouchEnabled and 32 or 26, Scrollbar = UserInputService.TouchEnabled and 6 or 4,
		DropItem = UserInputService.TouchEnabled and 32 or 28, DropMax = UserInputService.TouchEnabled and 220 or 180,
		TabHeight = UserInputService.TouchEnabled and 42 or 36, TabFont = UserInputService.TouchEnabled and 16 or 14,
		BodyPadX = 18, RowExtra = 8,
	}
	local screen = inst("ScreenGui", { Name = "PaybackUI", ResetOnSpawn = false, ZIndexBehavior = Enum.ZIndexBehavior.Global, Parent = GuiParent(), DisplayOrder = 999999 })
	screen.IgnoreGuiInset = true
	local dim = inst("Frame", { BackgroundColor3 = Color3.new(0,0,0), BackgroundTransparency = 1, Position = UDim2.fromOffset(-2,-2), Size = UDim2.new(1,4,1,4), Parent = screen, ZIndex = 5 })
	local blurObj = inst("BlurEffect", { Name = "PaybackBlur", Size = 0, Parent = Lighting })
	local w = env.IsMobile and math.min(math.floor(vw * 0.96), 900) or 900
	local h = env.IsMobile and math.min(math.floor(vh * 0.86), 660) or 620
	local main = inst("Frame", { Name = "Main", BackgroundColor3 = theme.Background, BackgroundTransparency = 0.06, Size = UDim2.fromOffset(w,h), Parent = screen, ZIndex = 10 })
	main.AnchorPoint = Vector2.new(0.5,0.5); main.Position = UDim2.fromScale(0.5,0.5)
	inst("UICorner", { CornerRadius = UDim.new(0,14), Parent = main })
	inst("UIStroke", { ApplyStrokeMode = Enum.ApplyStrokeMode.Border, Color = theme.Stroke, Thickness = 1, Transparency = 0.22, Parent = main })
	local shell = inst("Frame", { BackgroundTransparency = 1, Size = UDim2.fromScale(1,1), Position = UDim2.fromOffset(0,0), Parent = main, ZIndex = 11 })
	local top = inst("Frame", { Name = "Topbar", BackgroundColor3 = theme.Panel, BackgroundTransparency = 0.04, Size = UDim2.new(1,0,0,52), Parent = shell, ZIndex = 15 })
	inst("UICorner", { CornerRadius = UDim.new(0,12), Parent = top })
	inst("UIStroke", { ApplyStrokeMode = Enum.ApplyStrokeMode.Border, Color = theme.Stroke, Thickness = 1, Transparency = 0.22, Parent = top })
	inst("Frame", { BackgroundColor3 = theme.Accent, BorderSizePixel = 0, AnchorPoint = Vector2.new(0.5,1), Position = UDim2.new(0.5,0,1,0), Size = UDim2.new(1,-8,0,2), Parent = top, ZIndex = 16 })

	local title = inst("TextLabel", {
		BackgroundTransparency = 1, Font = Enum.Font.GothamBlack, Text = (o.Title or "Payback"),
		TextSize = env.IsMobile and 20 or 18, TextColor3 = theme.TextPrimary, TextXAlignment = Enum.TextXAlignment.Left,
		Position = UDim2.fromOffset(14,0), Size = UDim2.new(1,-340,1,0), Parent = top, ZIndex = 16,
	})
	local tgrad = inst("UIGradient", { Parent = title, Rotation = 0 })
	tgrad.Color = ColorSequence.new({
		ColorSequenceKeypoint.new(0.00, Color3.fromRGB(72,132,255)),
		ColorSequenceKeypoint.new(0.18, Color3.fromRGB(115,84,255)),
		ColorSequenceKeypoint.new(0.36, Color3.fromRGB(172,66,255)),
		ColorSequenceKeypoint.new(0.54, Color3.fromRGB(255,66,171)),
		ColorSequenceKeypoint.new(0.72, Color3.fromRGB(255,110,96)),
		ColorSequenceKeypoint.new(0.90, Color3.fromRGB(255,170,66)),
		ColorSequenceKeypoint.new(1.00, Color3.fromRGB(255,210,120)),
	})

	local searchO = inst("Frame", { BackgroundColor3 = theme.Panel2, BackgroundTransparency = 0.10, AnchorPoint = Vector2.new(1,0.5), Position = UDim2.new(1,-86,0.5,0), Size = UDim2.fromOffset(240,32), Parent = top, ZIndex = 16 })
	inst("UICorner", { CornerRadius = UDim.new(0,8), Parent = searchO })
	inst("UIStroke", { ApplyStrokeMode = Enum.ApplyStrokeMode.Border, Color = theme.Stroke, Thickness = 1, Transparency = 0.24, Parent = searchO })
	local search = inst("TextBox", { BackgroundTransparency = 1, PlaceholderText = "Search features…", Text = "", Font = Enum.Font.Gotham, TextSize = 14, TextColor3 = theme.TextPrimary, PlaceholderColor3 = theme.TextMuted, Position = UDim2.fromOffset(8,0), Size = UDim2.new(1,-8,1,0), Parent = searchO, ZIndex = 17, ClearTextOnFocus = false })

	local btnClose = inst("TextButton", { AutoButtonColor = false, BackgroundTransparency = 1, Text = "×", Font = Enum.Font.GothamBlack, TextSize = 22, TextColor3 = theme.TextMuted, AnchorPoint = Vector2.new(1,0.5), Position = UDim2.new(1,-6,0.5,0), Size = UDim2.fromOffset(24,24), Parent = top, ZIndex = 16 })
	local btnMin   = inst("TextButton", { AutoButtonColor = false, BackgroundTransparency = 1, Text = "–", Font = Enum.Font.GothamBlack, TextSize = 24, TextColor3 = theme.TextMuted, AnchorPoint = Vector2.new(1,0.5), Position = UDim2.new(1,-36,0.5,0), Size = UDim2.fromOffset(24,24), Parent = top, ZIndex = 16 })

	local body = inst("Frame", { BackgroundTransparency = 1, Position = UDim2.fromOffset(0,60), Size = UDim2.new(1,0,1,-(60+28)), Parent = shell, ZIndex = 12, ClipsDescendants = true })
	local tabbar = inst("Frame", { BackgroundTransparency = 1, Size = UDim2.new(1,0,0,env.TabHeight), Parent = body, ZIndex = 13 })
	inst("UIListLayout", { Parent = tabbar, FillDirection = Enum.FillDirection.Horizontal, Padding = UDim.new(0,8) })
	local pages = inst("Frame", { Name = "Pages", BackgroundTransparency = 1, Position = UDim2.fromOffset(0, env.TabHeight + 8), Size = UDim2.new(1,0,1,-(env.TabHeight+8)), Parent = body, ZIndex = 12, ClipsDescendants = true })
	local pageLayout = inst("UIPageLayout", { Parent = pages, EasingStyle = Enum.EasingStyle.Quad, EasingDirection = Enum.EasingDirection.Out, Padding = UDim.new(0,8), Animated = true, Circular = false, TweenTime = 0.25 })

	local status = inst("Frame", { BackgroundColor3 = theme.Panel, BackgroundTransparency = 0.04, AnchorPoint = Vector2.new(0.5,1), Position = UDim2.new(0.5,0,1,0), Size = UDim2.new(1,0,0,26), Parent = shell, ZIndex = 14 })
	inst("UICorner", { CornerRadius = UDim.new(0,8), Parent = status })
	inst("UIStroke", { ApplyStrokeMode = Enum.ApplyStrokeMode.Border, Color = theme.Stroke, Thickness = 1, Transparency = 0.24, Parent = status })
	local statusText = inst("TextLabel", { BackgroundTransparency = 1, Text = "Payback ready.", Font = Enum.Font.Gotham, TextSize = 12, TextColor3 = theme.TextMuted, TextXAlignment = Enum.TextXAlignment.Left, Position = UDim2.fromOffset(8,0), Size = UDim2.new(1,-40,1,0), Parent = status, ZIndex = 15 })
	-- clickable info icon on the right
	local infoBtn = inst("TextButton", { AutoButtonColor=false, BackgroundTransparency=1, Text="ⓘ", Font=Enum.Font.GothamBold, TextSize=14, TextColor3 = theme.TextMuted, AnchorPoint=Vector2.new(1,0.5), Position=UDim2.new(1,-8,0.5,0), Size=UDim2.fromOffset(22,22), Parent=status, ZIndex=16 })

	-- appear + blur
	local scale = inst("UIScale", { Parent = main, Scale = 0.92 })
	main.Visible = false
	task.delay(0.05, function()
		if alive(main) then
			main.Visible = true
			safeTween(scale, 0.22, { Scale = 1 }, Enum.EasingStyle.Quint)
			safeTween(main, 0.18, { BackgroundTransparency = 0.06 })
			safeTween(dim, 0.2, { BackgroundTransparency = 0.48 })
			safeTween(blurObj, 0.2, { Size = (env.IsMobile and 12 or 16) })
		end
	end)

	-- mobile reopen float button
	local floatBtn: TextButton? = nil
	if env.IsMobile then
		floatBtn = inst("TextButton", {
			AutoButtonColor=false, Text="☰", Font=Enum.Font.GothamBold, TextSize=18, TextColor3=theme.TextPrimary,
			BackgroundColor3 = theme.Panel2, BackgroundTransparency = 0.12, Size = UDim2.fromOffset(44,44),
			Position = UDim2.new(1,-54,1,-54), AnchorPoint = Vector2.new(0,0),
			Parent = screen, ZIndex = 30, Visible = false,
		})
		inst("UICorner", { CornerRadius = UDim.new(0,8), Parent = floatBtn })
		inst("UIStroke", { ApplyStrokeMode = Enum.ApplyStrokeMode.Border, Color = theme.Stroke, Thickness = 1, Transparency = 0.25, Parent = floatBtn })
		local dragging = false; local offset = Vector2.zero
		floatBtn.InputBegan:Connect(function(i)
			if i.UserInputType == Enum.UserInputType.Touch or i.UserInputType == Enum.UserInputType.MouseButton1 then
				dragging = true; offset = i.Position - floatBtn!.AbsolutePosition
			end
		end)
		floatBtn.InputEnded:Connect(function(i)
			if i.UserInputType == Enum.UserInputType.Touch or i.UserInputType == Enum.UserInputType.MouseButton1 then dragging = false end
		end)
		UserInputService.InputChanged:Connect(function(i)
			if dragging and (i.UserInputType == Enum.UserInputType.MouseMovement or i.UserInputType == Enum.UserInputType.Touch) then
				local p = i.Position - offset
				floatBtn!.Position = UDim2.fromOffset(math.clamp(p.X, 4, screen.AbsoluteSize.X - 48), math.clamp(p.Y, 4, screen.AbsoluteSize.Y - 48))
			end
		end)
		floatBtn.MouseButton1Click:Connect(function() ripple(floatBtn!, nil); -- reopen
			window:Toggle(true)
		end)
	end

	-- search filter
	local _winRef: any = nil
	local function applySearchFilter()
		local w = _winRef; if not w then return end
		local q = string.lower(search.Text or ""); local current = pageLayout.CurrentPage; if not current then return end
		local active = w._activeTab; if not active then for _, t in ipairs(w.Tabs or {}) do if t.Page == current then active = t break end end end
		if not active or not active._index then return end
		for _, pair in ipairs(active._index) do (pair[2] :: Frame).Visible = (q == "" or string.find(pair[1], q, 1, true) ~= nil) end
	end
	search:GetPropertyChangedSignal("Text"):Connect(applySearchFilter)

	-- window object
	local window = setmetatable({
		Screen = screen, Dim = dim, Main = main, Top = top, Status = statusText, _infoBtn = infoBtn,
		TabBar = tabbar, Pages = pages, PageLayout = pageLayout, Tabs = {},
		Theme = theme, Config = Config.new(o.ConfigDir or "Payback-UI"), Notifier = createNotifier(screen, theme),
		Watermark = createWatermark(screen, theme), Env = env, _visible = true, _alive = true, _blur = blurObj,
		_activeTab = nil, _rainbowEnabled = true, _floatBtn = floatBtn,
	}, Window)
	_winRef = window

	-- continuous rainbow loop (no pause)
	local tAccum = -1
	local rainbowConn: RBXScriptConnection? = nil
	local function rebuildRainbow()
		if rainbowConn then rainbowConn:Disconnect(); rainbowConn = nil end
		if not window._rainbowEnabled then tgrad.Offset = Vector2.new(0,0); return end
		rainbowConn = RunService.RenderStepped:Connect(function(dt)
			if not alive(title) then if rainbowConn then rainbowConn:Disconnect() end return end
			tAccum += dt * 0.25 -- speed
			if tAccum > 1 then tAccum -= 2 end -- wrap (-1..1)
			tgrad.Offset = Vector2.new(tAccum, 0)
		end)
	end
	rebuildRainbow()

	-- info modal
	local function openInfo()
		local overlay = inst("TextButton", { AutoButtonColor=false, Text="", BackgroundTransparency=0.4, BackgroundColor3=Color3.new(0,0,0), Size=UDim2.fromScale(1,1), Position=UDim2.fromOffset(0,0), ZIndex=999, Parent=screen })
		local modal = inst("Frame", { BackgroundColor3 = theme.Panel, BackgroundTransparency = 0.04, Size = UDim2.fromOffset(360,200), ZIndex=1000, Parent=screen })
		inst("UICorner", { CornerRadius = UDim.new(0,10), Parent = modal })
		inst("UIStroke", { ApplyStrokeMode = Enum.ApplyStrokeMode.Border, Color = theme.Stroke, Thickness = 1, Transparency = 0.22, Parent = modal })
		local titleL = inst("TextLabel", { BackgroundTransparency = 1, Text = "About Payback", Font = Enum.Font.GothamBold, TextSize = 16, TextColor3 = theme.TextPrimary, TextXAlignment = Enum.TextXAlignment.Left, Position = UDim2.fromOffset(12,8), Size = UDim2.fromOffset(320,20), Parent = modal, ZIndex = 1001 })
		local infoL = inst("TextLabel", {
			BackgroundTransparency = 1, Text = "Creator: Szekche / PaybackHub\nVersion: 1.0.0\nThis menu is not open source.\nPermission required to use.\n© Payback 2025",
			Font = Enum.Font.Gotham, TextSize = 14, TextColor3 = theme.TextMuted, TextXAlignment = Enum.TextXAlignment.Left, TextWrapped = true,
			Position = UDim2.fromOffset(12,34), Size = UDim2.fromOffset(336,120), Parent = modal, ZIndex = 1001,
		})
		local okB = inst("TextButton", { AutoButtonColor=false, Text="OK", Font=Enum.Font.GothamBold, TextSize=14, TextColor3=theme.TextPrimary, BackgroundColor3=theme.Accent, Size=UDim2.fromOffset(76,26), Position=UDim2.new(1,-88,1,-38), Parent=modal, ZIndex=1002 })
		inst("UICorner", { CornerRadius = UDim.new(0,6), Parent = okB })
		local function place()
			local ax = main.AbsolutePosition.X + (main.AbsoluteSize.X - 360) / 2
			local ay = main.AbsolutePosition.Y + (main.AbsoluteSize.Y - 200) / 2
			modal.Position = UDim2.fromOffset(math.floor(ax), math.floor(ay))
		end
		place(); local rs = RunService.RenderStepped:Connect(function() if alive(modal) then place() else rs:Disconnect() end end)
		local function close() if overlay then overlay:Destroy() end if modal then modal:Destroy() end end
		overlay.MouseButton1Click:Connect(close); okB.MouseButton1Click:Connect(close)
	end
	infoBtn.MouseButton1Click:Connect(function() ripple(infoBtn, nil); openInfo() end)

	-- drag window (desktop)
	if not env.IsMobile then
		local function makeDraggable(frame: Frame, handle: GuiObject?, cutoffY: number?)
			handle = handle or frame; cutoffY = cutoffY or 999; (handle :: GuiObject).Active = true
			(handle :: GuiObject).InputBegan:Connect(function(input: InputObject)
				if input.UserInputType == Enum.UserInputType.MouseButton1 then
					local rel = input.Position.Y - (handle :: GuiObject).AbsolutePosition.Y
					if rel <= (cutoffY :: number) then
						local startPos = frame.Position; local start = UserInputService:GetMouseLocation()
						while UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) do
							local d = UserInputService:GetMouseLocation() - start
							frame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + d.X, startPos.Y.Scale, startPos.Y.Offset + d.Y)
							RunService.RenderStepped:Wait()
						end
					end
				end
			end)
		end
		makeDraggable(main, top, 52)
	end

	-- keybind to toggle menu (default Insert)
	local openKey: Enum.KeyCode = (o.Keybind and (typeof(o.Keybind)=="EnumItem" and o.Keybind or Enum.KeyCode[tostring(o.Keybind)])) or Enum.KeyCode.Insert
	local keyConn = UserInputService.InputBegan:Connect(function(i, gpe) if gpe then return end if i.KeyCode == openKey and window._alive then window:Toggle() end end)

	btnClose.InputBegan:Connect(function(i) if i.UserInputType == Enum.UserInputType.MouseButton1 then ripple(btnClose, (i :: any).Position) end end)
	btnMin.InputBegan:Connect(function(i) if i.UserInputType == Enum.UserInputType.MouseButton1 then ripple(btnMin, (i :: any).Position) end end)
	btnClose.MouseButton1Click:Connect(function() window:Toggle(false) end)
	btnMin.MouseButton1Click:Connect(function() window:Toggle(false) end)

	-- public helpers
	function window:ApplyTheme(t: {[string]: any})
		for k,v in pairs(t or {}) do if (self.Theme :: any)[k] ~= nil then (self.Theme :: any)[k] = v end end
		-- quick recolor pass on main surfaces
		if alive(main) then main.BackgroundColor3 = self.Theme.Background end
		if alive(top) then top.BackgroundColor3 = self.Theme.Panel end
		if alive(status) then status.BackgroundColor3 = self.Theme.Panel end
		if alive(self._infoBtn) then (self._infoBtn :: TextButton).TextColor3 = self.Theme.TextMuted end
		-- tab underlines
		for _, t in ipairs(self.Tabs) do if alive(t.Under) then (t.Under :: Frame).BackgroundColor3 = self.Theme.Accent end end
	end
	function window:SetDimAlpha(a: number) safeTween(self.Dim, 0.15, { BackgroundTransparency = 1 - math.clamp(a,0,1) }) end
	function window:SetBlurPower(p: number) if self._blur then safeTween(self._blur, 0.15, { Size = math.max(0,p) }) end end
	function window:SetFPSVisible(b: boolean) self.Watermark:Show(b and true or false) end
	function window:Notify(o2: NotifierArg) self.Notifier(o2) end
	function window:SetRainbowEnabled(b: boolean) self._rainbowEnabled = b; rebuildRainbow() end
	function window:SetMenuHotkey(k: Enum.KeyCode?)
		if keyConn then keyConn:Disconnect(); keyConn = nil end
		openKey = k or Enum.KeyCode.Insert
		keyConn = UserInputService.InputBegan:Connect(function(i, gpe) if gpe then return end if i.KeyCode == openKey and self._alive then self:Toggle() end end)
	end

	function window:AddTab(name: string)
		local tab = setmetatable({ Name = name or "Tab", TabBar = self.TabBar, Pages = self.Pages, Theme = self.Theme, Config = self.Config, Screen = self.Screen, Env = self.Env }, Tab)
		tab._index = {}
		tab:_build(self.Theme, self.Env, function(label: string, frame: Frame) tab._index[#tab._index+1] = { string.lower(tostring(label or "")), frame } end)
		table.insert(self.Tabs, tab)
		tab.Select = function()
			for _, t in ipairs(self.Tabs) do t.Button.TextColor3 = self.Theme.TextMuted; t.Under.Visible = false end
			tab.Button.TextColor3 = self.Theme.TextPrimary; tab.Under.Visible = true
			self.PageLayout:JumpTo(tab.Page); self._activeTab = tab; applySearchFilter()
		end
		tab.Button.MouseButton1Click:Connect(function() self.Status.Text = (name or "Tab") .. " selected." end)
		if #self.Tabs == 1 then tab.Select() end
		return { Controls = function(_: any, side: string?) return tab:Controls(side) end, Section = function(_: any, label: string, side: string?) return tab:AddSection(label, side) end, Raw = tab }
	end

	function window:Toggle(force: boolean?)
		if not self._alive or not alive(self.Main) then return end
		if force ~= nil then self._visible = force else self._visible = not self._visible end
		local sc = self.Main:FindFirstChildOfClass("UIScale") :: UIScale?
		if self._visible then
			self.Main.Visible = true; if sc then safeTween(sc, 0.18, { Scale = 1 }) end
			safeTween(self.Main, 0.14, { BackgroundTransparency = 0.06 })
			safeTween(self.Dim, 0.14, { BackgroundTransparency = 0.48 })
			safeTween(self._blur, 0.2, { Size = (self.Env.IsMobile and 12 or 16) })
			if self._floatBtn then self._floatBtn.Visible = false end
		else
			if sc then safeTween(sc, 0.16, { Scale = 0.92 }) end
			safeTween(self.Main, 0.16, { BackgroundTransparency = 1 })
			safeTween(self.Dim, 0.16, { BackgroundTransparency = 1 })
			safeTween(self._blur, 0.2, { Size = 0 })
			task.delay(0.17, function() if alive(self.Main) then self.Main.Visible = false end end)
			if self._floatBtn then self._floatBtn.Visible = true end
		end
	end

	function window:Unload()
		self._alive = false; getgenv().Payback.Unloaded = true
		safeTween(self.Main, 0.12, { BackgroundTransparency = 1 })
		safeTween(self.Dim, 0.12, { BackgroundTransparency = 1 })
		if self._blur then safeTween(self._blur, 0.18, { Size = 0 }) end
		task.delay(0.13, function() if self.Screen then self.Screen:Destroy() end if self._blur then self._blur:Destroy() end end)
	end

	Workspace.CurrentCamera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
		if alive(main) and Workspace.CurrentCamera then
			local vs = Workspace.CurrentCamera.ViewportSize
			main.Size = UDim2.fromOffset(math.min(w, vs.X - 40), math.min(h, vs.Y - 40))
			main.Position = UDim2.fromScale(0.5,0.5)
		end
	end)

	----------------------------------------------------------------
	-- Built-in default tabs (always created)
	----------------------------------------------------------------
	-- UI Settings
	do
		local T = window:AddTab("UI Settings")
		local S1 = T:Section("Theme", "left")
		local S2 = T:Section("Display", "right")

		-- Unified menu color
		S1:ColorPicker({
			Name = "Menu Color (Unified)", Flag = "ui_unified_color", Default = window.Theme.Accent,
			Callback = function(c: Color3)
				local h,s,v = Color3.toHSV(c)
				-- derive gentle grays tinted by hue
				window:ApplyTheme({
					Accent = c,
					Background = Color3.fromHSV(h, math.clamp(s*0.15,0,0.30), math.clamp(v*0.12 + 0.08, 0, 1)),
					Panel      = Color3.fromHSV(h, math.clamp(s*0.18,0,0.35), math.clamp(v*0.16 + 0.10, 0, 1)),
					Panel2     = Color3.fromHSV(h, math.clamp(s*0.22,0,0.38), math.clamp(v*0.20 + 0.12, 0, 1)),
					Stroke     = Color3.fromHSV(h, 0.15, 0.35),
				})
			end
		})
		S1:Divider()
		S1:ColorPicker({ Name = "Accent",  Flag = "ui_accent",  Default = window.Theme.Accent,  Callback = function(c) window:ApplyTheme({ Accent = c }) end })
		S1:ColorPicker({ Name = "Panel",   Flag = "ui_panel",   Default = window.Theme.Panel,   Callback = function(c) window:ApplyTheme({ Panel = c }) end })
		S1:ColorPicker({ Name = "Panel 2", Flag = "ui_panel2",  Default = window.Theme.Panel2,  Callback = function(c) window:ApplyTheme({ Panel2 = c }) end })
		S1:ColorPicker({ Name = "Bg",      Flag = "ui_bg",      Default = window.Theme.Background, Callback = function(c) window:ApplyTheme({ Background = c }) end })

		S2:Toggle({
			Name = "Rainbow Title", Flag = "ui_rainbow", Default = true,
			Callback = function(on) window:SetRainbowEnabled(on and true or false) end
		})
		S2:Slider({
			Name = "Blur Power", Flag = "ui_blur", Min = 0, Max = 30, Step = 1, Default = env.IsMobile and 12 or 16,
			Callback = function(v) window:SetBlurPower(v) end
		})
		S2:Toggle({
			Name = "FPS Watermark", Flag = "ui_fps", Default = false,
			Callback = function(b) window:SetFPSVisible(b) end
		})
		S2:Label("Tip: Use Search (top right) to filter controls on the active tab.")
	end

	-- Config (same behavior, saves everything incl. calling script controls)
	local SaveManager = {}
	do
		-- SaveManager impl is appended after return (below). We create here:
	end

	-- System: Unload + Set menu hotkey
	do
		local T = window:AddTab("System")
		local L = T:Section("Unload & Hotkey", "left")
		local R = T:Section("Actions", "right")

		-- menu hotkey
		L:Keybind({
			Name = "Open/Close Menu Key", Flag = "ui_menu_key", Default = openKey,
			Callback = function(k) window:SetMenuHotkey(k) end
		})

		R:Button({
			Name = "Unload UI",
			Callback = function()
				window:Notify({ Title = "Payback", Content = "Unloading…", Duration = 2 })
				task.delay(0.2, function() window:Unload() end)
			end
		})
	end

	-- Build Config tab now that SaveManager exists (below we attach methods)
	return window
end

----------------------------------------------------------------
-- Save manager
----------------------------------------------------------------
local SaveManager = {}
local function sanitize(name: string?): string
	name = tostring(name or ""):gsub("^%s+",""):gsub("%s+$",""):gsub("[^%w_%-%s]","_"):gsub("%s+","_"):sub(1,32)
	if name == "" then name = "default" end
	return name
end
function SaveManager:SetLibrary(win: any) self.Window = win return self end
function SaveManager:SetFolder(p: string?) self.Folder = p or "Payback-UI" return self end
function SaveManager:SetIgnoreIndexes(list: {string}?) self.Ignore = {}; for _,k in ipairs(list or {}) do self.Ignore[k] = true end return self end
function SaveManager:Collect()
	local out = {}
	for k,v in pairs(getgenv().Payback.Toggles) do if not (self.Ignore and self.Ignore[k]) then out[k] = v.Value end end
	for k,v in pairs(getgenv().Payback.Options) do if not (self.Ignore and self.Ignore[k]) then out[k] = v.Value end end
	for k,v in pairs(self.Window.Config.Values) do if out[k] == nil and not (self.Ignore and self.Ignore[k]) then out[k] = v end end
	return out
end
function SaveManager:Apply(t: {[string]: any})
	if type(t) ~= "table" then return end
	for k,v in pairs(t) do
		if getgenv().Payback.Toggles[k] then getgenv().Payback.Toggles[k]:SetValue(v)
		elseif getgenv().Payback.Options[k] then getgenv().Payback.Options[k]:SetValue(v)
		else self.Window.Config:Set(k, v) end
	end
end
function SaveManager:Save(name: string?)
	local cfg = self.Window.Config; cfg.Directory = self.Folder or cfg.Directory
	for k,v in pairs(self:Collect()) do cfg:Set(k, v) end
	return cfg:Save(sanitize(name))
end
function SaveManager:Load(name: string?)
	local ok, err = self.Window.Config:Load(sanitize(name))
	if ok then self:Apply(self.Window.Config.Values) end
	return ok, err
end
function SaveManager:List(): {string}
	local path = (self.Folder or self.Window.Config.Directory); local list: {string} = {}
	if isfolder and isfile then
		if not isfolder(path) then return list end
		local ok, files = pcall(function() return listfiles(path) end)
		if ok and type(files) == "table" then
			for _, fp in ipairs(files) do if type(fp) == "string" and fp:sub(-5) == ".json" then list[#list+1] = (fp:match("[^/\\]+$") or fp):gsub("%.json$","") end end
		end
	end
	table.sort(list); return list
end
function SaveManager:BuildConfigTab(tabObj: any)
	local left = tabObj:Section("Configuration", "left")
	local right = tabObj:Section("Manage", "right")
	left:Textbox({ Name = "Config Name", Placeholder = "e.g. legit1", Flag = "cfg_name" })
	local function currentName(): string
		local opt = getgenv().Payback.Options["cfg_name"]; local n = opt and tostring(opt.Value or "") or ""; return sanitize(n)
	end
	left:Button({ Name = "Save", Callback = function() local name = currentName(); local ok, err = self:Save(name); self.Window:Notify({ Title = "Config", Content = ok and ("Saved '"..name.."'") or ("Save failed: "..tostring(err)), Duration = 3 }); self:_refresh() end })
	left:Button({ Name = "Load Selected", Callback = function() local sel = self._selected; if sel then local ok, err = self:Load(sel); self.Window:Notify({ Title = "Config", Content = ok and ("Loaded '"..sel.."'") or ("Load failed: "..tostring(err)), Duration = 3 }) else self.Window:Notify({ Title = "Config", Content = "No config selected.", Duration = 3 }) end self:_refresh() end })
	left:Toggle({ Name = "Autoload selected on start", Flag = "cfg_autoload", Default = false })
	left:Button({ Name = "Set Autoload", Callback = function()
		if not writefile then self.Window:Notify({ Title = "Config", Content = "Filesystem unavailable", Duration = 3 }); return end
		local folder = self.Folder or self.Window.Config.Directory; if makefolder and not isfolder(folder) then makefolder(folder) end
		local name = self._selected or currentName(); writefile(folder.."/autoload.txt", name)
		self.Window:Notify({ Title = "Config", Content = "Autoload = "..name, Duration = 3 })
	end })
	left:Button({ Name = "Delete Selected", Callback = function()
		local sel = self._selected; if not sel then self.Window:Notify({ Title = "Config", Content = "Nothing selected to delete.", Duration = 2 }); return end
		if not (isfile and delfile) then self.Window:Notify({ Title = "Config", Content = "Filesystem unavailable", Duration = 3 }); return end
		local path = (self.Folder or self.Window.Config.Directory) .. "/" .. sel .. ".json"
		if isfile(path) then delfile(path); self.Window:Notify({ Title = "Config", Content = "Deleted '"..sel.."'.", Duration = 2 }); self._selected = nil; self:_refresh()
		else self.Window:Notify({ Title = "Config", Content = "File not found.", Duration = 2 }) end
	end })

	local holder = right.Holder
	local list = inst("ScrollingFrame", { BackgroundTransparency = 1, CanvasSize = UDim2.fromOffset(0,0), AutomaticCanvasSize = Enum.AutomaticSize.Y, ScrollBarThickness = 6, Parent = holder, ZIndex = holder.ZIndex + 1, Size = UDim2.new(1,0,0,300) })
	inst("UIGridLayout", { Parent = list, CellPadding = UDim2.fromOffset(12,12), CellSize = UDim2.fromOffset(180,64), FillDirectionMaxCells = 2, SortOrder = Enum.SortOrder.LayoutOrder })
	function self:_refresh()
		for _, c in ipairs(list:GetChildren()) do if c:IsA("Frame") then c:Destroy() end end
		for _, name in ipairs(self:List()) do
			local card = inst("Frame", { BackgroundColor3 = self.Window.Theme.Panel2, BackgroundTransparency = 0.40, Size = UDim2.fromOffset(180,64), Parent = list, ZIndex = list.ZIndex + 1 })
			inst("UICorner", { CornerRadius = UDim.new(0,10), Parent = card })
			inst("UIStroke", { ApplyStrokeMode = Enum.ApplyStrokeMode.Border, Color = self.Window.Theme.Stroke, Thickness = 1, Transparency = 0.30, Parent = card })
			local selBar = inst("Frame", { BackgroundColor3 = self.Window.Theme.Accent, BackgroundTransparency = 0.8, Size = UDim2.new(0,4,1,0), Parent = card, ZIndex = card.ZIndex + 1 })
			inst("TextLabel", { BackgroundTransparency = 1, Text = name, Font = Enum.Font.GothamBold, TextSize = 14, TextColor3 = self.Window.Theme.TextPrimary, TextXAlignment = Enum.TextXAlignment.Left, Position = UDim2.fromOffset(10,6), Size = UDim2.new(1,-20,0,18), Parent = card, ZIndex = card.ZIndex + 1 })
			local ts = inst("TextLabel", { BackgroundTransparency = 1, Text = "Select", Font = Enum.Font.Gotham, TextSize = 12, TextColor3 = self.Window.Theme.TextMuted, TextXAlignment = Enum.TextXAlignment.Left, Position = UDim2.fromOffset(10,28), Size = UDim2.new(1,-20,0,18), Parent = card, ZIndex = card.ZIndex + 1 })
			card.InputBegan:Connect(function(i)
				if i.UserInputType == Enum.UserInputType.MouseButton1 then
					ripple(card, (i :: any).Position); self._selected = name
					for _, c2 in ipairs(list:GetChildren()) do if c2:IsA("Frame") then local b = c2:FindFirstChildOfClass("Frame"); if b then (b :: Frame).BackgroundTransparency = 0.8 end end end
					selBar.BackgroundTransparency = 0.3; ts.Text = "Selected"
				end
			end)
		end
	end
	self:_refresh()
end
function SaveManager:LoadAutoload()
	if not (readfile and isfile) then return false end
	local folder = self.Folder or self.Window.Config.Directory; local path = folder .. "/autoload.txt"
	if isfile(path) then local name = readfile(path); self._selected = name; return self:Load(name) end
	return false
end

----------------------------------------------------------------
-- API
----------------------------------------------------------------
local API = {}; API.__index = API; API.version = "7.4"
function API.new(key: string, options: { Title: string?, Accent: Color3?, Keybind: any?, ConfigDir: string?, Theme: ThemeT? }?)
	if key ~= SECRET then return nil, "INVALID_KEY" end
	local lib = setmetatable({}, PaybackLib)
	local win = lib:CreateWindow(options or {})
	-- attach SaveManager defaults and build Config tab (auto-load)
	local sm = setmetatable({}, { __index = SaveManager })
	sm:SetLibrary(win):SetFolder((options and options.ConfigDir) or "Payback-UI"):SetIgnoreIndexes({})
	local ConfigTab = win:AddTab("Config"); sm:BuildConfigTab(ConfigTab)
	sm:LoadAutoload()
	return win, sm
end

return setmetatable({}, API)
